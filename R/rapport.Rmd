---
title: "Rapport de suivi"
subtitle: "`r paste0('Du ', params$rapport_debut, ' au ', params$rapport_fin)`"
output:
    html_document:
      toc: true
      toc_float: true
      toc_depth: 3
params:
  rapport_debut: ""
  rapport_fin: ""
  proj_dir: ""
  n_dr: ""
  n_menages_dr: ""
  n_menages_remplacement: ""
  serveur: ""
  utilisateur_api: ""
  passe_api: ""
  menage_fichier: ""
  comm_fichier: ""
  masque_menage: ""
  masque_comm: ""
  workspace: ""
  statuses_to_review: ""
  nom_fichier_calories: ""
  nom_fichier_facteurs: ""
  facteurs_niv: ""
  facteurs_prod_id: ""
  facteurs_region: ""
  facteurs_milieu: ""
  facteurs_unite: ""
  facteurs_taille: ""
  facteurs_poids: ""
  grappe_var: ""
  region_var: ""
  departement_var: ""
  commune_var: ""
  milieu_var: ""
  dr_var: ""
  sup_exclus: ""
---

```{r knitr_options, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE}

# knitr options
knitr::opts_chunk$set(
	echo = FALSE, 
	warning = FALSE,
	message = FALSE,
	out.width = '100%')

```

```{r set_folders}
# scripts
script_dir <- paste0(params$proj_dir, "R/")
# data
data_dir <- paste0(params$proj_dir, "data/") # /data/
hhold_dir <- paste0(data_dir, "hhold/")
comm_dir <- paste0(data_dir, "community/")
sync_dir <- paste0(data_dir, "sync/")
# household
hh_resource_dir <- paste0(hhold_dir, "00_resource/")  # /00_resource/
hh_download_dir <- paste0(hhold_dir, "01_downloaded/")  # /01_downloaded/
hh_combined_dir <- paste0(hhold_dir, "02_combined/")  # /02_combined/
hh_derived_dir <- paste0(hhold_dir, "03_derived/")   # /03_derived/
# community
comm_download_dir <- paste0(comm_dir, "01_downloaded/")  # /01_downloaded/
comm_combined_dir <- paste0(comm_dir, "02_combined/")  # /02_combined/

```

```{r load_libraries}
# load necessary libraries where functions may not have namespace indicated
library(dplyr) # need %>%
library(lubridate) # need %within%
library(reactable) # might have functions used without namespace
```

```{css}

h1 {
    color: #0F2B1D;
}

h2 {
    color: #516A5D;
}

```

```{r define_functions}
#' Replace `NaN` and `Inf` with `NA_real_`
#' 
#' Replace NaN, which results from division by 0, with NA. This makes data destined for tables easier to handle.
#' 
#' @param df Data frame
#' 
#' @importFrom dplyr `%>%` mutate across 
replace_nan_inf <- function(df) {

    df %>%
    dplyr::mutate(
        dplyr::across(
            .cols = where(is.numeric),
            # note: using base::ifelse() rather than dplyr::if_else() to avoid type issues
            .fns = ~ ifelse(
                test = is.nan(.x), 
                yes = NA_real_,
                no = .x
            )
        ),
        dplyr::across(
            .cols = where(is.numeric),
            .fns = ~ ifelse(
                test = is.infinite(.x), 
                yes = NA_real_,
                no = .x
            )
        )
    )

}

#' Apply style to tables
#' 
#' Apply styles from `gt::tab_options()` to tables
#' 
#' @param df Data frame
#' @param heading_color Character. Hex color for table header background color.
#' @param column_label_color Character. Hex color for column label background color.
#' @param row_group_color  Character. Hex color for row group background color.
#' 
#' @export 
style_table <- function(
    df, 
    heading_color = "#0F2B1D",
    column_label_color = "#264535",
    row_group_color = "#516A5D"
) {

    df %>%
    # apply colors to header, column labels, and row groups
    gt::tab_options(
        heading.background.color = heading_color,
        column_labels.background.color = column_label_color,
        row_group.background.color = row_group_color
    ) %>%
    # replace NA with ---
    gt::fmt_missing(columns = everything())

}

# {reactable} table style
reactable_style <- reactable::reactableTheme(
    headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
    groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
    stripedColor = "#edfaea",
    searchInputStyle = list(
        backgroundColor = "#edfaea",
        borderColor = "#8cc0a5",
        borderWidth = "medium",
        "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
        "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
        "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
    )
)

# reactable UI text
reactable_fr <- reactable::reactableLang(
    searchPlaceholder = "Rechercher",
    searchLabel = "Rechercher",
    noData = "Aucune ligne retrouvée",
    pageNext = "Suivant",
    pagePrevious = "Précédent",
    pageNumbers = "{page} de {pages}",
    pageInfo = "Lignes {rowStart} à {rowEnd} de {rows} lignes"
)

flag_calories_low_high <- function(
    df,
    low_color = "orange",
    high_color = "red"
) {

    df %>%
    # styling for low values
    gt::tab_style(
        style = list(
            gt::cell_text(color = low_color)
        ),
        locations = gt::cells_body(
            columns = minimum,
            rows = minimum < 800
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = low_color)
        ),
        locations = gt::cells_body(
            columns = lower_hinge,
            rows = lower_hinge < 800
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = low_color)
        ),
        locations = gt::cells_body(
            columns = median,
            rows = median < 800
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = low_color)
        ),
        locations = gt::cells_body(
            columns = upper_hinge,
            rows = upper_hinge < 800
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = low_color)
        ),
        locations = gt::cells_body(
            columns = maximum,
            rows = maximum < 800
        )
    ) %>%
    # styling for higher values
    gt::tab_style(
        style = list(
            gt::cell_text(color = high_color)
        ),
        locations = gt::cells_body(
            columns = minimum,
            rows = minimum >= 4000
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = high_color)
        ),
        locations = gt::cells_body(
            columns = lower_hinge,
            rows = lower_hinge >= 4000
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = high_color)
        ),
        locations = gt::cells_body(
            columns = median,
            rows = median >= 4000
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = high_color)
        ),
        locations = gt::cells_body(
            columns = upper_hinge,
            rows = upper_hinge >= 4000
        )
    ) %>%
    gt::tab_style(
        style = list(
            gt::cell_text(color = high_color)
        ),
        locations = gt::cells_body(
            columns = maximum,
            rows = maximum >= 4000
        )
    )

}

#' Interview completion info
#' 
#' Get the date and interviewer for last completion event
#' 
#' @param df Interview actions data set
#' 
#' @importFrom dplyr `%>%` group_by filter row_number n ungroup rename select
interview_complete <- function(df) {

    responsibles <- df %>%
        dplyr::group_by(interview__id, interview__key) %>% # group by interview identifiers
        dplyr::filter(responsible__role == 1) %>% # interviewer provided answers
        dplyr::filter(dplyr::row_number() == dplyr::n()) %>% # take last obs in group
        dplyr::ungroup() %>%
        dplyr::rename(
            interviewer_last_complete = responsible__name,
            date_last_complete = date
        ) %>%
        dplyr::select(
            interview__id, interview__key, 
            interviewer_last_complete, date_last_complete
        )

    return(responsibles)

}

interview_date <- function(df) {

    date_complete <- df %>%
        dplyr::group_by(interview__id, interview__key) %>% # group by interview identifiers
        dplyr::filter(responsible__role == 1) %>% # interviewer provided answers
        dplyr::filter(dplyr::row_number() == dplyr::n()) %>% # take last obs in group
        dplyr::ungroup() %>%
        dplyr::select(interview__id, interview__key, date)

    return(date_complete)

}

#' Load the full Stata data
#' 
#' Ingest data from .dta files
#' 
#' @param dir Character. Directory where Stata file is located
#' @param file Character. File name with `.dta` extension.
#' @param name Character. Name to give ingested data in global environment.
#' 
#' @importFrom haven read_data
load_full <- function(
    dir,
    file,
    name = gsub(pattern = "\\.dta", replacement = "", x = file)
) {

    df <- haven::read_dta(file = paste0(dir, file))

    assign(
        x = name,
        value = df,
        envir = .GlobalEnv
    )

}

#' Filter a data frame in place
#' 
#' Replace df in environment with a filtered version of it
#' 
#' @param name Character. Name of a data frame
#' @param filter_df Data frame used to filter. Must contain keys `interview__id` and `interview__key`
#' 
#' @importFrom dplyr semi_join
filter_in_place <- function(
    name,
    filter_df
) {

    df_filtered <- base::get(name, envir = .GlobalEnv) |>
        dplyr::semi_join(filter_df, by = c("interview__id", "interview__key"))

    assign(
        x = name,
        value = df_filtered,
        envir = .GlobalEnv
    )

}

load_filtered <- function(
    dir,
    file,
    name = gsub(pattern = "\\.dta", replacement = "", x = file),
    filter_df
) {
    df <- haven::read_dta(file = paste0(dir, file))
    
    df_filtered <- df %>%
        dplyr::semi_join(filter_df, by = c("interview__id", "interview__key"))
    
    assign(
        x = name,
        value = df_filtered,
        envir = .GlobalEnv
    )
    
}

```

```{r identify_cases}

# question: which statuses should be considered for the report?

cases_to_review <- haven::read_dta(file = paste0(hh_combined_dir, params$menage_fichier)) %>%
    # selon le statut SuSo
    dplyr::filter(interview__status %in% params$statuses_to_review) %>%
    # selon les données de l'entretien
    dplyr::filter(
        # résultat: achevé
        (s00q08 %in% c(1, 2))
        & 
        # toutes les visites faites
        (visite1 == 1 & visite2 == 2 & visite3 == 3)
    ) %>%
    dplyr::mutate(interview_complete = 1) %>%
    dplyr::select(interview__id, interview__key, interview_complete, interview__status)
```

```{r load_raw_data}

fichiers <- c(
    params$menage_fichier, "membres.dta", "parcelles.dta",
    "interview__actions.dta", "interview__errors.dta", "interview__diagnostics.dta", "interview__comments.dta"
)
fichier_noms <- c(
    "menages", "membres", "parcelles",
    "suso_actions", "suso_errors", "suso_diagnostics", "comments"
)

# charger toutes les données
purrr::walk2(
    .x = fichiers, 
    .y = fichier_noms,
    .f = ~ load_full(
        dir = hh_combined_dir,
        file = .x,
        name = .y
    )
)

community <- haven::read_dta(file = paste0(comm_combined_dir, params$comm_fichier))

```

```{r gather_hh_metadata}
# =============================================================================
# Load
# =============================================================================

# sync date
interviews_info <- paste0(sync_dir, "interview_sync_dates.xlsx") |>
    readxl::read_excel() |>
    dplyr::mutate(
        date_component = stringr::str_sub(updateDateUtc, start = 1L, end = 10L),
        suso_update_date = lubridate::ymd(date_component),
        responsibleName = dplyr::if_else(
            condition = responsibleRole == "INTERVIEWER",
            true = responsibleName,
            false = NA_character_
        )
    ) |>
    dplyr::select(
        interview__id = id, interview__key = key,
        suso_update_date, 
        interviewer = responsibleName, 
        supervisor = supervisorName
    )    

# completion date
interviews_last_completed <- interview_complete(df = suso_actions)

# =============================================================================
# Compile
# =============================================================================

# compile metadata
interview_metadata <- menages |>
    dplyr::left_join(interviews_info, by = c("interview__id", "interview__key")) |>
    dplyr::left_join(interviews_last_completed, by = c("interview__id", "interview__key")) |>
    dplyr::mutate(
        # entretien achevé
        is_complete = dplyr::if_else(
            condition = (
                # un statut SuSo où jugé potentiellement finalisé
                (interview__status %in% params$statuses_to_review)
                &
                # résultat: achevé
                (s00q08 %in% c(1, 2))
                &
                # toutes les visites faites
                (visite1 == 1 & visite2 == 2 & visite3 == 3)
            ),
            true = TRUE,
            false = FALSE,
            missing = FALSE
        ),
        # responsable si la personne responsable n'est pas une enquêteur
        interviewer = dplyr::if_else(
            condition = is.na(interviewer),
            true = interviewer_last_complete,
            false = interviewer
        ),
        # date d'achèvement
        date = lubridate::as_date(date_last_complete),
        # semaine d'achèvement
        week = lubridate::floor_date(
            x = date, 
            unit = "week", 
			week_start = getOption("lubridate.week.start", 1)
        ),
        # dans la période du rapport
        report_period = date %within% 
            lubridate::interval(
                start = params$rapport_debut, 
                end = params$rapport_fin
            )
    ) |>
    dplyr::select(
        # identifiants
        interview__id, interview__key,
        # achèvement
        is_complete,
        # date
        date, week, 
        report_period,
        # responsable
        supervisor, interviewer
    )

```

```{r preserve_and_filter_dfs}

# garder la base intégrale
menages_tous <- menages

# cas à garder cas à garder: les entretiens achevés
cases_to_keep <- interview_metadata |>
    dplyr::filter(is_complete == TRUE)

# trier les bases
purrr::walk(
    .x = fichier_noms,
    .f = ~ filter_in_place(
        name = .x, 
        filter_df = cases_to_keep
    )
)

```

```{r create_derived_data, results='hide'}
# combine food data
source(paste0(script_dir, "combine_food.R"))

# compute calories
# create objects expected by program
resource_dir    <- hh_resource_dir
derived_dir     <- params$hh_derived_dir
nom_fichier_calories <- params$nom_fichier_calories
nom_fichier_facteurs <- params$nom_fichier_facteurs
facteurs_niv    <- params$facteurs_niv
facteurs_prod_id <- params$facteurs_prod_id
facteurs_region <- params$facteurs_region
facteurs_milieu <- params$facteurs_milieu
facteurs_unite  <- params$facteurs_unite
facteurs_taille <- params$facteurs_taille
facteurs_poids  <- params$facteurs_poids
# run script
source(paste0(script_dir, "calculate_calories.R"))
```

```{r load_derived_data}

purrr::walk(
    .x = c("consommation_alimentaire_7d.dta", "calories_totales.dta", "calories_par_item.dta"),
    .f = ~ load_filtered(
        dir = hh_derived_dir,
        file = .x,
        filter_df = cases_to_keep
    )
)

```

# 1. Progrès

```{r progress_gauges, out.width='100%'}
menages_attendus <- params$n_dr * params$n_menages_dr
menages_acheves <- nrow(menages)

gauge_n_menages <- echarts4r::e_charts() |>
    echarts4r::e_gauge(
        value = round(100 * (menages_acheves / menages_attendus), digits = 1),
        name = glue::glue("{menages_acheves} / {menages_attendus}"),
        title = list(
            offsetCenter = list(0, '100%')
        ),        
        pointer = list(
            itemStyle = list(
                color = "#0F2B1D"
            )
        ),
        progress = list(
            show = TRUE,
            itemStyle = list(
                color = "#264535"
            )
        ),
        splitLine = list(
            lineStyle = list(
                color = "#516A5D"
            )
        ),
        detail = list(
            formatter = "{value}%",
            color = "#264535",
            fontSize = 25,
            offsetCenter = list(0, '75%')
        ),
        radius = '40%'
    ) |>
    echarts4r::e_title(
        text = "Ménages",
        left = "center",
        textStyle = list(
            fontSize = 40,
            color = "#0F2B1D"
        )
    )

dr_attendus <- params$n_dr
dr_acheves <- dplyr::distinct(community, !!rlang::data_sym(params$grappe_var)) |> nrow()

gauge_n_dr <- echarts4r::e_charts() |>
    echarts4r::e_gauge(
        value = round(100 * (dr_acheves / dr_attendus), digits = 2),
        name = glue::glue("{dr_acheves} / {dr_attendus}"),
        title = list(
            offsetCenter = list(0, '100%')
        ),        
        pointer = list(
            itemStyle = list(
                color = "#0F2B1D"
            )
        ),
        progress = list(
            show = TRUE,
            itemStyle = list(
                color = "#264535"
            )
        ),
        splitLine = list(
            lineStyle = list(
                color = "#516A5D"
            )
        ),
        detail = list(
            formatter = "{value}%",
            color = "#264535",
            fontSize = 25,
            offsetCenter = list(0, '75%')
        ),
        radius = '40%'
    ) |>
    echarts4r::e_title(
        text = "DRs",
        left = "center",
        textStyle = list(
            fontSize = 40,
            color = "#0F2B1D"
        )
    )

echarts4r::e_arrange(gauge_n_menages, gauge_n_dr, rows = 1, cols = 2)

```

# 2. Statut par ZD

```{r status_by_ea}

hhold_metadata <- menages_tous |>
    dplyr::select(
        interview__id, interview__key,
        grappe,
        dplyr::matches("s00q0[1-7]$"),
        s00q08
    ) |>
    dplyr::left_join(interviews_info, by = c("interview__id", "interview__key")) |>
    dplyr::select(-c(interview__id, interview__key))

hhold_stats <- hhold_metadata |>
    dplyr::mutate(
        dplyr::across(
            .cols = c(s00q01, s00q02, s00q03, s00q04, s00q06),
            .fns = ~ haven::as_factor(.x),
            .names = "fct_{.col}"
        ),
        ea = glue::glue("Région: {fct_s00q01}, Département: {fct_s00q02}, Commune: {fct_s00q03}, Milieu: {fct_s00q04}, ZD: {fct_s00q06}"),
        n_hholds_filled = s00q08 %in% c(1, 2)
    ) |>
    dplyr::group_by(ea, grappe, supervisor) |>
    dplyr::summarise(
        hhold_update_date = max(suso_update_date, na.rm = TRUE),
        n_hholds_received = dplyr::n(),
        n_hholds_filled = sum(n_hholds_filled, na.rm = TRUE),
        dplyr::across(
            .cols = c(s00q01, s00q02, s00q03, s00q04, s00q06),
            .fns = ~ dplyr::first(.x)
        )
    ) |>
    dplyr::ungroup()

community_metadata <- community |>
    # keep SuSo and geo IDs
    dplyr::select(
        interview__id, interview__key,
        !!rlang::data_sym(params$grappe_var),
        !!rlang::data_sym(params$region_var), 
        !!rlang::data_sym(params$departement_var), 
        !!rlang::data_sym(params$commune_var), 
        !!rlang::data_sym(params$milieu_var), 
        !!rlang::data_sym(params$dr_var)  
    ) |>
    # assign geo IDs to standard geo ID names
    dplyr::mutate(
        grappe = !!rlang::data_sym(params$grappe_var),
        s00q01 = !!rlang::data_sym(params$region_var), 
        s00q02 = !!rlang::data_sym(params$departement_var), 
        s00q03 = !!rlang::data_sym(params$commune_var), 
        s00q04 = !!rlang::data_sym(params$milieu_var), 
        s00q06 = !!rlang::data_sym(params$dr_var)              
    ) |>
    # create an EA name from community components
    dplyr::mutate(
        dplyr::across(
            .cols = c(s00q01, s00q02, s00q03, s00q04, s00q06),
            .fns = ~ haven::as_factor(.x),
            .names = "fct_{.col}"
        ),
        ea_comm = glue::glue("Région: {fct_s00q01}, Département: {fct_s00q02}, Commune: {fct_s00q03}, Milieu: {fct_s00q04}, ZD: {fct_s00q06}")
    ) |>
    dplyr::left_join(interviews_info, by = c("interview__id", "interview__key")) |>
    dplyr::select(-c(interview__id, interview__key))

community_stats <- community_metadata |>
    dplyr::group_by(grappe, s00q01, s00q02, s00q03, s00q04, s00q06) |>
    dplyr::summarise(
        comm_update_date = max(suso_update_date, na.rm = TRUE),
        n_comm_received = dplyr::n(),
        ea_comm = dplyr::first(ea_comm)
    ) |>
    dplyr::ungroup()

ea_stats <- dplyr::full_join(
        hhold_stats, community_stats, 
        by = "grappe"
    ) |>
    dplyr::mutate(
        ea = dplyr::if_else(
            condition = is.na(ea), 
            true = ea_comm,
            false = ea
        ),
        n_comm_received = dplyr::if_else(
            condition = is.na(n_comm_received),
            true = 0L,
            false = n_comm_received
        ),
        hh_complete = dplyr::case_when(
            # case 1: exhausted all households (i.e., sampled + replacement)
            n_hholds_received == params$n_menages_dr + params$n_menages_remplacement ~ TRUE,
            # case 2: received as many completed interviews as households sampled per EA
            n_hholds_filled == params$n_menages_dr ~ TRUE,
            TRUE ~ FALSE
        ),
        comm_complete = dplyr::if_else(
            condition = n_comm_received %in% c(1, 2),
            true = TRUE,
            false = FALSE,
            missing = FALSE
        ),       
        ea_status = dplyr::case_when(
            # case 1: more household or community questionnaires received than expected
            (n_hholds_filled > params$n_menages_dr + params$n_menages_remplacement) | (n_comm_received > 2) ~ "Erreur",
            # case 2: all expected hhold and community received
            hh_complete == TRUE & comm_complete == TRUE ~ "Achevé",
            # case 3: hhold and/or community quetionnaires
            dplyr::if_any(
                .cols = c(hh_complete, comm_complete),
                .fns = ~ .x %in% c(FALSE, NA)
            ) ~ "En cours",
        ) 
    ) |>
    dplyr::select(
        ea,
        grappe, 
        ea_status,
        supervisor,
        hhold_update_date, hh_complete, n_hholds_received, n_hholds_filled,
        comm_update_date, comm_complete, n_comm_received
    )

reactable::reactable(
    data = ea_stats,
    defaultColDef = reactable::colDef(
        minWidth = 100,
        maxWidth = 100,
        align = "center",
        na = "-"
    ),
    columns = list(
        ea = reactable::colDef(
            name = "DR",
            minWidth = 300,
            maxWidth = 700,
            align = "left"
        ),
        grappe = reactable::colDef(
            name = "Grappe"
        ),
        ea_status = reactable::colDef(
            name = "Statut",
            cell = function(value) {
                if (value == "Achevé") {
                    color <- "background: #99e388; color: #2e7c1d;"
                } else if (value == "En cours") {
                    color <- "background: #fdd6ce; color: #aa2308;"
                } else if (value == "Erreur") {
                    color <- "background: #E2BF1C; color: #F0590A"
                }
                htmltools::div(
                    style = paste(
                        "display: inline-block; padding: 2px 12px; border-radius: 15px; font-weight: 600; font-size: 12px;",
                        color    
                    ),
                    value
                )
            }
        ),
        supervisor = reactable::colDef(
            name = "Équipe",
            width = 150
        ),
        hhold_update_date = reactable::colDef(
            name = "Dernière sync"            
        ),
        hh_complete = reactable::colDef(
            name = "Achevé",
            minWidth = 75,
            maxWidth = 75,
            cell = function(value) {
                if (value == TRUE) {
                    status <- fontawesome::fa_i(name = "check", style = "color: #2e7c1d;")
                } else if (value == FALSE) {
                    status <- fontawesome::fa_i(name = "times", style = "color: #aa2308;")
                }
                status
            }
        ),
        n_hholds_received = reactable::colDef(
            name = "Reçu", 
            width = 75
        ),
        n_hholds_filled = reactable::colDef(
            name = "Rempli",
            width = 75
        ),        
        comm_update_date = reactable::colDef(
            name = "Dernière sync"
        ),
        comm_complete = reactable::colDef(
            name = "Achevé",
            minWidth = 75,
            maxWidth = 75,
            cell = function(value) {
                if (value == TRUE) {
                    status <- fontawesome::fa_i(name = "check", style = "color: #2e7c1d;")
                } else if (value == FALSE) {
                    status <- fontawesome::fa_i(name = "times", style = "color: #aa2308;")
                }
                status
            }
        ),
        n_comm_received = reactable::colDef(
            name = "Reçu"
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Ménage",
            columns = c("hhold_update_date", "hh_complete", "n_hholds_received", "n_hholds_filled")
        ),
        reactable::colGroup(
            name = "Communauté",
            columns = c("comm_update_date", "comm_complete", "n_comm_received")
        )
    ),
    filterable = TRUE,
    striped = TRUE,
    searchable = TRUE,
    compact = TRUE,
    fullWidth = FALSE,
    theme = reactable::reactableTheme(
        headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
        groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
        stripedColor = "#edfaea",
        searchInputStyle = list(
            backgroundColor = "#edfaea",
            borderColor = "#8cc0a5",
            borderWidth = "medium",
            "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
            "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
            "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
        )
    ),
    language = reactable_fr 
    
)

```

```{r get_teams_interviews}
# obtenir les équipes du serveur: superviseurs et leurs enquêteurs
equipes <- susoapi::get_supervisors(workspace = params$workspace) %>%
    dplyr::select(supervisor = UserName)

# obtenir le vecteur de supeviseurs à exclure
if (params$sup_exclus == "") {
    exclus <- ""
} else {
    exclus <- unlist(strsplit(
        x = params$sup_exclus,
        split = ",[ ]*"
    ))
}

# créer la base des équipes à retenir
enqueteur_par_equipe <- equipes %>%
    {
        if (length(exclus) == 0) {
            . 
        } else {
            dplyr::filter(., ! supervisor %in% exclus)
        }
    }

# base des entretiens achevés avec la date de d'achèvement
enqueteur_par_entretien <- interview_metadata

equipe_enqueteur_entretien <- enqueteur_par_equipe %>%
    dplyr::left_join(enqueteur_par_entretien, by = "supervisor")

menages_ehcvm1 <- dplyr::filter(menages_tous, s00q07d == 1)
```

# 3. Taux de réponse 

## 3.1. Global

```{r response_overall}
reponse_globale_counts <- equipe_enqueteur_entretien %>%
    dplyr::filter(report_period %in% c(TRUE, NA)) %>%
    dplyr::left_join(menages_tous, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        n_entretiens = !is.na(interview__id),
        n_rempli = s00q08 %in% c(1, 2),
        n_non_rempli = s00q08 %in% c(3, NA),
        nr_abandon = s00q09 == 1,
        nr_refus = s00q09 == 2,
        nr_vacant = s00q09 == 3,
        nr_sans_motif = n_non_rempli == TRUE & is.na(s00q09)
    ) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        dplyr::across(
            .cols = c(
                n_entretiens, n_rempli, 
                n_non_rempli, nr_abandon, nr_refus, nr_vacant, nr_sans_motif
            ),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup() 
    
reponse_globale_by_group <- reponse_globale_counts %>%
    # compute stats
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("nr_"),
            .fns = ~ .x / n_non_rempli
        ),
        p_rempli = n_rempli / n_entretiens,
        p_non_rempli = n_non_rempli / n_entretiens
    ) %>%
    replace_nan_inf()

reponse_globale_overall <- reponse_globale_counts %>%
    # overall counts
    dplyr::summarise(
        dplyr::across(
            .cols = c(
                n_entretiens, n_rempli, 
                n_non_rempli, nr_abandon, nr_refus, nr_vacant, nr_sans_motif
            ),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    # compute stats
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("nr_"),
            .fns = ~ .x / n_non_rempli
        ),
        p_rempli = n_rempli / n_entretiens,
        p_non_rempli = n_non_rempli / n_entretiens
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

reponse_globale <- dplyr::bind_rows(
    reponse_globale_overall, reponse_globale_by_group
)

reponse_globale %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(title = "Taux de réponse globale") %>%
gt::fmt_percent(
    columns = c(p_rempli, p_non_rempli)
) %>%
gt::tab_style(
    style = list(
        gt::cell_text(
            style = "italic",
            color = "red"
        )
    ),
    locations = gt::cells_body(
        columns = n_rempli,
        rows = p_rempli < .90
    )
) %>%
gt::cols_merge_n_pct(
    col_n = n_rempli,
    col_pct = p_rempli
) %>%
gt::cols_merge_n_pct(
    col_n = n_non_rempli,
    col_pct = p_non_rempli
) %>%
gt::fmt_number(
    columns = c(nr_abandon, nr_refus, nr_vacant, nr_sans_motif),
    scale_by = 100
) %>%
gt::cols_label(
    n_entretiens = gt::html("Entretiens<br>(N)"),
    n_rempli = gt::html("Rempli<br>(N)"),
    n_non_rempli = gt::html("Non-rempli<br>(N)"),
    nr_abandon = "Abandon",
    nr_refus = "Refus",
    nr_vacant = "Vacant",
    nr_sans_motif = gt::html("Sans<br>motif")
) %>%
gt::tab_spanner(
    label = "Motif de non-réponse (%)",
    columns = dplyr::starts_with("nr_")
) %>%
style_table()
```

## 3.2 Anciens ménages

```{r response_panel}
reponse_anciens_menages_counts <- equipe_enqueteur_entretien %>%
    dplyr::filter(report_period %in% c(TRUE, NA)) %>%
    dplyr::inner_join(menages_ehcvm1, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        n_entretiens = !is.na(interview__id),
        n_rempli = s00q08 %in% c(1, 2),
        n_non_rempli = s00q08 %in% c(3, NA),
        nr_abandon = s00q09 == 1,
        nr_refus = s00q09 == 2,
        nr_vacant = s00q09 == 3,
        nr_sans_motif = n_non_rempli == TRUE & is.na(s00q09)
    ) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        dplyr::across(
            .cols = c(
                n_entretiens, n_rempli, 
                n_non_rempli, nr_abandon, nr_refus, nr_vacant, nr_sans_motif
            ),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup()

reponse_anciens_menages_by_group <- reponse_anciens_menages_counts %>%
    # compute stats
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("nr_"),
            .fns = ~ .x / n_non_rempli
        ),
        p_rempli = n_rempli / n_entretiens,
        p_non_rempli = n_non_rempli / n_entretiens
    ) %>%
    replace_nan_inf()

reponse_anciens_menages_overall <- reponse_anciens_menages_counts %>%
    # overall counts
    dplyr::summarise(
        dplyr::across(
            .cols = c(
                n_entretiens, n_rempli, 
                n_non_rempli, nr_abandon, nr_refus, nr_vacant, nr_sans_motif
            ),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    # compute stats
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("nr_"),
            .fns = ~ .x / n_non_rempli
        ),
        p_rempli = n_rempli / n_entretiens,
        p_non_rempli = n_non_rempli / n_entretiens
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

# combine group and overall stats
reponse_anciens_menages <- dplyr::bind_rows(
    reponse_anciens_menages_overall, reponse_anciens_menages_by_group
)

reponse_anciens_menages %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(title = "Taux de réponse chez les anciens ménages") %>%
gt::fmt_percent(
    columns = c(p_rempli, p_non_rempli)
) %>%
gt::tab_style(
    style = list(
        gt::cell_text(
            style = "italic",
            color = "red"
        )
    ),
    locations = gt::cells_body(
        columns = n_rempli,
        rows = p_rempli < .90
    )
) %>%
gt::cols_merge_n_pct(
    col_n = n_rempli,
    col_pct = p_rempli
) %>%
gt::cols_merge_n_pct(
    col_n = n_non_rempli,
    col_pct = p_non_rempli
) %>%
gt::fmt_number(
    columns = c(nr_abandon, nr_refus, nr_vacant, nr_sans_motif),
    scale_by = 100
) %>%
gt::cols_label(
    n_entretiens = gt::html("Entretiens<br>(N)"),
    n_rempli = gt::html("Rempli<br>(N)"),
    n_non_rempli = gt::html("Non-rempli<br>(N)"),
    nr_abandon = "Abandon",
    nr_refus = "Refus",
    nr_vacant = "Vacant",
    nr_sans_motif = gt::html("Sans<br>motif")    
) %>%
gt::tab_spanner(
    label = "Motif de non-réponse (%)",
    columns = dplyr::starts_with("nr_")
) %>%
style_table()
```

# 4 Taille du ménage

## 4.1 Tous les ménages

```{r hhold_size_all}
# indicators by interview
taille_menage_by_interview <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(menages, by = c("interview__id", "interview__key")) %>%
    dplyr::left_join(membres, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        n_membres = (
            # membre
            (
            # ... ancien
            (!is.na(preload_pid) & s01q00a == 1) 
            |
            # ... nouveau
            (is.na(preload_pid))
            )
            & 
            # non-visiteur
            (s01q12 == 1 | s01q13 == 1)
        )
    ) %>%
    # household-level counts
    dplyr::group_by(interview__id, interview__key, supervisor) %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        n_membres = sum(n_membres, na.rm = TRUE),
        dplyr::across(
            .cols = c(report_period, week),
            .fns = ~ dplyr::first(.x)
        )
    ) %>%
    dplyr::ungroup() 

# report week stats
taille_menage_by_group <- taille_menage_by_interview %>%
    dplyr::filter(report_period %in% c(TRUE, NA)) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_menages = sum(n_menages, na.rm = TRUE),
        minimum = fivenum(n_membres, na.rm = TRUE)[1], 
        lower_hinge = fivenum(n_membres, na.rm = TRUE)[2], 
        median = fivenum(n_membres, na.rm = TRUE)[3], 
        upper_hinge = fivenum(n_membres, na.rm = TRUE)[4], 
        maximum = fivenum(n_membres, na.rm = TRUE)[5]
    ) %>%
    dplyr::ungroup() %>%
    replace_nan_inf()
    
taille_menage_overall <- taille_menage_by_interview %>%
    dplyr::filter(report_period %in% c(TRUE, NA)) %>%
    dplyr::summarise(
        n_menages = sum(n_menages, na.rm = TRUE),
        minimum = fivenum(n_membres, na.rm = TRUE)[1], 
        lower_hinge = fivenum(n_membres, na.rm = TRUE)[2], 
        median = fivenum(n_membres, na.rm = TRUE)[3], 
        upper_hinge = fivenum(n_membres, na.rm = TRUE)[4], 
        maximum = fivenum(n_membres, na.rm = TRUE)[5]
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

taille_menage_this_week <- dplyr::bind_rows(taille_menage_overall, taille_menage_by_group)
    
# trend over time
taille_menage_trend_by_group <- taille_menage_by_interview |>
    # supervisor-week medians
    dplyr::group_by(supervisor, week) %>%
    dplyr::summarise(n_membres = median(n_membres, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    # supervisor-level series
    dplyr::arrange(supervisor, week) |>
    dplyr::group_by(supervisor) |>
    dplyr::summarise(taille_trend = list(n_membres)) |>
    dplyr::ungroup()

taille_menage_trend_overall <- taille_menage_by_interview |>
    # week medians
    dplyr::group_by(week) %>%
    dplyr::summarise(n_membres = median(n_membres, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    dplyr::filter(!is.na(week) & !is.na(n_membres)) |>
    # series
    dplyr::arrange(week) |>
    dplyr::summarise(taille_trend = list(n_membres)) |>
    dplyr::mutate(supervisor = "Ensemble") |>
    dplyr::relocate(supervisor)

taille_menage_trend <- dplyr::bind_rows(
    taille_menage_trend_overall, taille_menage_trend_by_group
)

# combine week and trend data
taille_menage_tbl <- taille_menage_this_week |>
    dplyr::full_join(taille_menage_trend, by = "supervisor")

# compose table
reactable::reactable(
    data = taille_menage_tbl,
    defaultColDef = reactable::colDef(
        width = 75
    ),
    columns = list(
        supervisor = reactable::colDef(
            name = "Équipe",
            width = 120
        ),
        n_menages = reactable::colDef(
            name = "N. Ménages",
            width = 100
        ),
        minimum = reactable::colDef(name = "Min"),
        lower_hinge = reactable::colDef(name = "Q1"),
        median = reactable::colDef("Méd"),
        upper_hinge = reactable::colDef("Q3"),
        maximum = reactable::colDef("Max"),
        taille_trend = reactable::colDef(
            name = "Tendance",
            width = 400,
            cell = function(value, index) {
                dataui::dui_sparkline(
                    data = value,
                    components = list(
                        dataui::dui_sparklineseries(
                            # styling
                            stroke = "#7E9384",
                            showArea = TRUE,
                            fill = "#7E9384"
                        ),
                        dataui::dui_tooltip(
                            dataui::dui_sparkpointseries(
                                #styling
                                stroke = "#7E9384",
                                fill = "#fff",
                                #litle extra interactivity for demostration purposes
                                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                            )
                        )
                    )
                )
            }
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Période du rapport",
            columns = c(
                "n_menages", 
                "minimum", "lower_hinge", "median", "upper_hinge", "maximum"
            )
        ),
        reactable::colGroup(
            name = "Période de l'enquête",
            columns = "taille_trend"
        )
    ),
    striped = TRUE,
    sortable = TRUE,
    searchable = TRUE,
    fullWidth = FALSE,
    compact = TRUE,
    theme = reactable_style,
    language = reactable_fr  
)

```

## 4.2 Anciens ménages

```{r hhold_size_panel}
taille_menage_ancien_counts <- equipe_enqueteur_entretien %>%  
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::semi_join(menages_ehcvm1, by = c("interview__id", "interview__key")) %>%
    dplyr::left_join(membres, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        n_membres_loaded = 1 & !is.na(preload_pid),
        n_membres = TRUE,
        n_membres_remain = n_membres_loaded == 1 & s01q00a == 1,
        n_members_left = n_membres_loaded == 1 & s01q00a == 2,
        n_membres_new = n_membres == 1 & is.na(preload_pid)
    ) %>%
    dplyr::group_by(interview__id, interview__key, supervisor) %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_membres, n_membres_new, n_membres_loaded, n_membres_remain, n_members_left),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup()

taille_menage_ancien_by_group <- taille_menage_ancien_counts %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_membres, n_membres_new, n_membres_loaded, n_membres_remain, n_members_left),
            .fns = ~ mean(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(
        supervisor,
        n_menages, n_membres, n_membres_loaded,
        n_membres_remain, n_members_left, n_membres_new
    ) %>%
    replace_nan_inf()

taille_menage_ancien_overall <- taille_menage_ancien_counts %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_membres, n_membres_new, n_membres_loaded, n_membres_remain, n_members_left),
            .fns = ~ mean(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::select(
        supervisor,
        n_menages, n_membres, n_membres_loaded,
        n_membres_remain, n_members_left, n_membres_new
    ) %>%
    replace_nan_inf()

taille_menage_ancien <- dplyr::bind_rows(
    taille_menage_ancien_overall, taille_menage_ancien_by_group
)

taille_menage_ancien %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(
    title = "Taille du ménage",
    subtitle = "Ménages de l'EHCVM"
) %>%
gt::cols_label(
    n_menages = gt::html("Entretiens<br>(N)"),
    n_membres_loaded    = "EHCVM 1",
    n_membres           = "EHCVM 2",
    n_membres_remain    = "Restés",
    n_members_left      = "Partis",
    n_membres_new       = "Arrivés"
) %>%
gt::tab_spanner(
    label = gt::html("Membres<br>(N)"),
    columns = c(n_membres_loaded, n_membres)
) %>%
gt::tab_spanner(
    label = gt::html("Changements<br>(N)"),
    columns = c(n_membres_new, n_membres_remain, n_members_left)
) %>%
gt::fmt_number(columns = everything()) %>%
style_table()
```

# 5 Déplacement de l'âge

```{r age_disp}
age_stats_counts <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(menages, by = c("interview__id", "interview__key")) %>%
    dplyr::left_join(membres, by = c("interview__id", "interview__key")) %>%
    dplyr::filter((is.na(preload_pid)) | (!is.na(preload_pid) & s01q00a == 1)) %>%
    dplyr::mutate(
        age_2 = AgeAnnee == 2,
        age_3 = AgeAnnee == 3,
        age_4 = AgeAnnee == 4,
        age_5 = AgeAnnee == 5,
        age_6 = AgeAnnee == 6,
        age_7 = AgeAnnee == 7,
        n_members_in_range = AgeAnnee %in% c(2:7)
    ) %>%
    dplyr::group_by(interview__id, interview__key, supervisor) %>%
    dplyr::summarise(
        dplyr::across(
            .cols = c(n_members_in_range, dplyr::starts_with("age_")),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup()

age_stats_by_group <- age_stats_counts %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_members_in_range, dplyr::starts_with("age_")),
            .fns = ~ sum(.x, na.rm = TRUE)
        )        
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
        ratio = age_5/age_4,
        ratio_extended = (age_5 + age_6)/(age_3 + age_4)
    ) %>%
    replace_nan_inf()

age_stats_overall <- age_stats_counts %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_members_in_range, dplyr::starts_with("age_")),
            .fns = ~ sum(.x, na.rm = TRUE)
        )        
    ) %>%
    dplyr::mutate(
        ratio = age_5/age_4,
        ratio_extended = (age_5 + age_6)/(age_3 + age_4)
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

age_stats <- dplyr::bind_rows(
    age_stats_overall, age_stats_by_group
)

age_stats %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(title = "Déplacement de l'âge, par équipe") %>%
gt::cols_label(
    n_menages = gt::html("Entretiens<br>(N)"),
    n_members_in_range = gt::html("Membres de 2 à 7<br>(N)"),
    age_2 = "2",
    age_3 = "3",
    age_4 = "4",
    age_5 = "5",
    age_6 = "6",
    age_7 = "7",
    ratio = gt::html("Ratio d'âge<br>(5/4)"),
    ratio_extended = gt::html("Ratio élargi<br>(5+6)/(3+4)")
) %>%
gt::tab_spanner(
    label = "Membres d'âge (N)",
    columns = dplyr::starts_with("age_")
) %>%
gt::fmt_number(columns = c(ratio, ratio_extended), decimals = 2) %>%
gt::tab_style(
    style = gt::cell_text(
        color = "red",
        style = "italic"
    ),
    locations = gt::cells_body(
        columns = c(ratio),
        rows = ratio < 0.8
    )
) %>%
gt::tab_style(
    style = gt::cell_text(
        color = "red",
        style = "italic"
    ),
    locations = gt::cells_body(
        columns = c(ratio_extended),
        rows = ratio_extended < 0.8
    )
) %>%
gt::tab_source_note(source_note = "Cible: un ratio d'âge de 0.8 ou plus") %>%
style_table()

```

# 6. Branche d'activité

```{r branche_text}

job_info <- equipe_enqueteur_entretien |>
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(membres, by = c("interview__id", "interview__key")) |>
    dplyr::select(
        interview__id, interview__key, dplyr::matches("__id$"),
        s04q30a, s04q30b, # primary
        s04q52a, s04q52b # secondary
    )

job1 <- job_info |>
    dplyr::mutate(emploi = "primaire") |>
    dplyr::select(
        interview__id, interview__key, dplyr::matches("__id$"),
        emploi,
        activity_desc = s04q30a, 
        activity_code = s04q30b
    )

job2 <- job_info |>
    dplyr::mutate(emploi = "secondaire") |>
    dplyr::select(
        interview__id, interview__key, dplyr::matches("__id$"),
        emploi,
        activity_desc = s04q52a, 
        activity_code = s04q52b        
    )

jobs <- dplyr::bind_rows(job1, job2) |>
    dplyr::filter(activity_code == 7) |>
    dplyr::select(-activity_code)

reactable::reactable(
    data = jobs,
    columns = list(
        interview__id = reactable::colDef(
            name = "id",
            width = 300
        ),
        interview__key = reactable::colDef(
            name = "key",
            width = 100
        ),
        membres__id = reactable::colDef(
            name = "pid",
            width = 75
        ),
        emploi = reactable::colDef(
            name = "Emploi",
            width = 100
        ),
        activity_desc = reactable::colDef(
            name = "Activité",
            width = 300
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Identifiants",
            columns = c("interview__id", "interview__key", "membres__id")
        )
    ),
    striped = TRUE,
    sortable = TRUE,
    filterable = TRUE,
    fullWidth = FALSE,
    compact = TRUE,
    theme = reactable_style,
    language = reactable_fr    
)

```

# 7. Nombre de produits alimentaires consommés

```{r num_products}
# counts by interview
n_produits_by_interview <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(consommation_alimentaire_7d, by = c("interview__id", "interview__key")) %>%
    # create indicator for each non-null record
    dplyr::mutate(
        count_produits = !is.na(interview__id)
    ) %>%
    # 
    dplyr::group_by(interview__id, interview__key, supervisor) %>%
    dplyr::summarise(
        n_entretiens = dplyr::n_distinct(interview__id, na.rm = TRUE),
        count_produits = sum(count_produits, na.rm = TRUE),
        dplyr::across(
            .cols = c(report_period, week),
            .fns = ~ dplyr::first(.x)            
        )
    ) %>%
    dplyr::ungroup()
    
# report week stats
n_produits_by_group <- n_produits_by_interview %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) 
    ) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_entretiens = sum(n_entretiens, na.rm = TRUE),
        minimum = fivenum(count_produits)[1], 
        lower_hinge = fivenum(count_produits)[2], 
        median = fivenum(count_produits)[3], 
        upper_hinge = fivenum(count_produits)[4], 
        maximum = fivenum(count_produits)[5]
    ) %>%   
    dplyr::ungroup() %>%
    replace_nan_inf()

n_produits_overall <- n_produits_by_interview %>%
    dplyr::filter(report_period == TRUE) %>%
    dplyr::summarise(
        n_entretiens = sum(n_entretiens, na.rm = TRUE),
        minimum = fivenum(count_produits)[1], 
        lower_hinge = fivenum(count_produits)[2], 
        median = fivenum(count_produits)[3], 
        upper_hinge = fivenum(count_produits)[4], 
        maximum = fivenum(count_produits)[5]
    ) %>%   
    dplyr::ungroup() %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

n_produits_this_week <- dplyr::bind_rows(
    n_produits_overall, n_produits_by_group
)

# trend over time
n_produits_trend_by_group <- n_produits_by_interview |>
    # supervisor-week medians
    dplyr::group_by(supervisor, week) %>%
    dplyr::summarise(count_produits = median(count_produits, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    # supervisor-level series
    dplyr::arrange(supervisor, week) |>
    dplyr::group_by(supervisor) |>
    dplyr::summarise(n_produits_trend = list(count_produits)) |>
    dplyr::ungroup()

n_produits_trend_overall <- n_produits_by_interview |>
    # week medians
    dplyr::group_by(week) %>%
    dplyr::summarise(count_produits = median(count_produits, na.rm = TRUE)) |>
    dplyr::ungroup() |>
    dplyr::filter(!is.na(week) & !is.na(count_produits)) |>
    # series
    dplyr::arrange(week) |>
    dplyr::summarise(n_produits_trend = list(count_produits)) |>
    dplyr::mutate(supervisor = "Ensemble") |>
    dplyr::relocate(supervisor)

n_produits_trend <- dplyr::bind_rows(
    n_produits_trend_overall, n_produits_trend_by_group
)

# combine week and trend data
n_produits_tbl <- n_produits_this_week |>
    dplyr::full_join(n_produits_trend, by = "supervisor")

# compose table
reactable::reactable(
    data = n_produits_tbl,
    defaultColDef = reactable::colDef(
        width = 75
    ),    
    columns = list(
        supervisor = reactable::colDef(
            name = "Équipe",
            width = 150
        ),
        n_entretiens = reactable::colDef(
            name = "N. Ménages",
            width = 100
        ),
        minimum = reactable::colDef(name = "Min"),
        lower_hinge = reactable::colDef(name = "Q1"),
        median = reactable::colDef("Méd"),
        upper_hinge = reactable::colDef("Q3"),
        maximum = reactable::colDef("Max"),
        n_produits_trend = reactable::colDef(
            name = "Tendance",
            width = 400,
            cell = function(value, index) {
                dataui::dui_sparkline(
                    data = value,
                    components = list(
                        dataui::dui_sparklineseries(
                            # styling
                            stroke = "#7E9384",
                            showArea = TRUE,
                            fill = "#7E9384"
                        ),
                        dataui::dui_tooltip(
                            dataui::dui_sparkpointseries(
                                #styling
                                stroke = "#7E9384",
                                fill = "#fff",
                                #litle extra interactivity for demostration purposes
                                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                            )
                        )
                    )
                )
            }
        )        
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Période du rapport",
            columns = c(
                "n_entretiens", 
                "minimum", "lower_hinge", "median", "upper_hinge", "maximum"
            )
        ),
        reactable::colGroup(
            name = "Période de l'enquête",
            columns = "n_produits_trend"
        )
    ),
    striped = TRUE,
    sortable = TRUE,
    searchable = TRUE,
    fullWidth = FALSE,
    compact = TRUE,
    theme = reactable_style,
    language = reactable_fr      
)

```

# 8. Calories 

## 8.1 Totales

```{r calories_total}
calories_frame <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(calories_totales, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(n_entretiens = !is.na(interview__id))

calories_by_group <- calories_frame %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_entretiens = sum(n_entretiens, na.rm = TRUE),       
        dplyr::across(
            .cols = c(n_consomme, p_calcule),
            .fns = ~ mean(.x, na.rm = TRUE)
        ),
        minimum = fivenum(calories_totales)[1], 
        lower_hinge = fivenum(calories_totales)[2], 
        median = fivenum(calories_totales)[3], 
        upper_hinge = fivenum(calories_totales)[4], 
        maximum = fivenum(calories_totales)[5]        
    ) %>%
    dplyr::ungroup() %>%
    replace_nan_inf()

calories_overall <- calories_frame %>%
    dplyr::summarise(
        n_entretiens = sum(n_entretiens, na.rm = TRUE),       
        dplyr::across(
            .cols = c(n_consomme, p_calcule),
            .fns = ~ mean(.x, na.rm = TRUE)
        ),
        minimum = fivenum(calories_totales)[1], 
        lower_hinge = fivenum(calories_totales)[2], 
        median = fivenum(calories_totales)[3], 
        upper_hinge = fivenum(calories_totales)[4], 
        maximum = fivenum(calories_totales)[5]        
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

calories_tbl <- dplyr::bind_rows(
    calories_overall, calories_by_group
)

calories_tbl %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(title = "Calories totales") %>%
gt::cols_label(
    n_entretiens = gt::html("Entretiens<br>(N)"),
    n_consomme = gt::html("Consommés<br>(N)"),
    p_calcule = gt::html("Calculés<br>(%)"),
    minimum = "Min",
    lower_hinge = "Q1",
    median = "Méd",
    upper_hinge = "Q3",
    maximum = "Max"
) %>%
gt::tab_spanner(
    label = "Produits",
    columns = c(n_consomme, p_calcule)
) %>%
gt::tab_spanner(
    label = "Distribution de calories",
    columns = c(minimum, lower_hinge, median, upper_hinge, maximum)
) %>%
gt::tab_style(
    style = gt::cell_fill(color = "#7E9384", alpha = 0.25),
    locations = gt::cells_body(
        columns = median, rows = dplyr::everything()
    )
) %>%
gt::fmt_percent(columns = p_calcule) %>%
gt::fmt_number(
    columns = c(minimum, lower_hinge, median, upper_hinge, maximum),
    decimals = 2
) %>%
flag_calories_low_high() %>%
style_table()

```

## 8.2 Part des groupes

```{r calories_p_group}
calories_groupe_counts <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(calories_par_item, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        groupe = dplyr::case_when(
            aliment__id %in% c(1:26, 167:169) ~ "p_cereales",
            aliment__id %in% c(27:39, 170, 171) ~ "p_viandes",
            aliment__id %in% c(40:51, 172, 173) ~ "p_poissons",
            aliment__id %in% c(52:60, 174) ~ "p_laitier",
            aliment__id %in% c(61:70, 175) ~ "p_huiles",
            aliment__id %in% c(71:87, 176) ~ "p_fruits",
            aliment__id %in% c(88:108, 177) ~ "p_legumes",
            aliment__id %in% c(109:133, 178) ~ "p_legtub",
            aliment__id %in% c(134:138) ~ "p_sucreries",
            aliment__id %in% c(139:154, 179) ~ "p_epices",
            aliment__id %in% c(155:165, 180, 181) ~ "p_boissons",
            TRUE ~ "autre"
        )
    ) %>%
    dplyr::group_by(interview__id, interview__key, supervisor, groupe) %>%
    dplyr::summarise(calories_par_groupe = sum(calories_par_produit, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
        id_cols = c(interview__id, interview__key, supervisor),
        names_from = groupe,
        values_from = calories_par_groupe
    ) %>%
    dplyr::select(-autre) %>%
    dplyr::left_join(calories_totales, by = c("interview__id", "interview__key")) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_menages = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(dplyr::starts_with("p_"), calories_totales),
            .fns = ~ sum(.x, na.rm = TRUE)
        )        
    ) %>%
    dplyr::ungroup() 
    
calories_groupe_by_group <- calories_groupe_counts %>%
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("p_"),
            .fns = ~ .x / calories_totales
        )
    ) %>%
    dplyr::select(
        supervisor,
        n_menages,
        p_cereales, p_viandes, p_poissons, p_laitier, p_huiles, p_fruits, 
        p_legumes, p_legtub, p_sucreries, p_epices, p_boissons
    ) %>%
    replace_nan_inf()

calories_groupe_overall <- calories_groupe_counts %>%
    dplyr::summarise(
        dplyr::across(
            .cols = c(n_menages, dplyr::starts_with("p_"), calories_totales),
            .fns = ~ sum(.x, na.rm = TRUE)
        )        
    ) %>%
    dplyr::mutate(
        dplyr::across(
            .cols = dplyr::starts_with("p_"),
            .fns = ~ .x / calories_totales
        )
    ) %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::select(
        supervisor,
        n_menages,
        p_cereales, p_viandes, p_poissons, p_laitier, p_huiles, p_fruits, 
        p_legumes, p_legtub, p_sucreries, p_epices, p_boissons
    ) %>%
    replace_nan_inf()

calories_groupe_tbl <- dplyr::bind_rows(
    calories_groupe_overall, calories_groupe_by_group
)

calories_groupe_tbl %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(title = "Part de calories par groupe") %>%
gt::cols_label(
    n_menages = gt::html("Ménages<br>(N)"),
    p_cereales = "Céréales",
    p_viandes = "Viandes",
    p_poissons = "Poissons",
    p_laitier = "Laitier",
    p_huiles = "Huiles",
    p_fruits = "Fruits",
    p_legumes = "Légumes",
    p_legtub = "Tubercules",
    p_sucreries = "Sucreries",
    p_epices = "Épices",
    p_boissons = "Boissons"
) %>%
gt::tab_spanner(
    label = "Part du groupe (%)",
    columns = dplyr::starts_with("p_")
) %>%
gt::fmt_number(
    columns = dplyr::starts_with("p_"),
    decimals = 2,
    scale_by = 100
) %>%
style_table()

```

# 9. Mesure de surface par GPS

```{r plot_gps}
gps_stats_counts <- equipe_enqueteur_entretien %>%
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::left_join(parcelles, by = c("interview__id", "interview__key")) %>%
    dplyr::mutate(
        n_parcelles = !is.na(parcelles__id),
        n_non_gps = s16Aq45 == 2,
        petit = s16Aq48 == 1,
        panne = s16Aq48 == 2,
        indisponible = s16Aq48 == 3,
        loin = s16Aq48 == 4,
        autre = s16Aq48 == 5,
        sans_motif = n_non_gps == TRUE & is.na(s16Aq48)
    ) %>%
    dplyr::group_by(supervisor) %>%
    dplyr::summarise(
        n_entretiens = dplyr::n_distinct(interview__id, na.rm = TRUE),
        dplyr::across(
            .cols = c(n_parcelles, n_non_gps, petit, panne, indisponible, loin, autre, sans_motif),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::ungroup()

gps_stats_by_group <- gps_stats_counts %>%
    dplyr::mutate(
        p_non_gps = n_non_gps / n_parcelles,
        dplyr::across(
            .cols = c(petit, panne, indisponible, loin, autre, sans_motif),
            .fns = ~ .x / n_non_gps
        )
    ) %>%
    replace_nan_inf()

gps_stats_by_overall <- gps_stats_counts %>%
    dplyr::summarise(
        dplyr::across(
            .cols = c(n_entretiens, n_parcelles, n_non_gps, petit, panne, indisponible, loin, autre, sans_motif),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) %>%
    dplyr::mutate(
        p_non_gps = n_non_gps / n_parcelles,
        dplyr::across(
            .cols = c(petit, panne, indisponible, loin, autre, sans_motif),
            .fns = ~ .x / n_non_gps
        )
    ) %>%
    replace_nan_inf() %>%
    dplyr::mutate(supervisor = "Ensemble") %>%
    dplyr::relocate(supervisor)

gps_stats <- dplyr::bind_rows(
    gps_stats_by_overall, gps_stats_by_group
)

gps_stats %>%
gt::gt(rowname_col = "supervisor") %>%
gt::tab_header(
    title = "Mesure de superficie par GPS",
    subtitle = "Taux l'absence de mesure et motifs"
) %>%
gt::fmt_percent(columns = p_non_gps) %>%
gt::tab_style(
    style = list(
        gt::cell_text(
            style = "italic",
            color = "red"
        )
    ),
    locations = gt::cells_body(
        columns = n_non_gps,
        rows = p_non_gps < .90
    )
) %>%
gt::cols_merge_n_pct(
    col_n = n_non_gps,
    col_pct = p_non_gps
) %>%
gt::cols_label(
    n_entretiens = gt::html("Entretiens<br>(N)"),
    n_parcelles = gt::html("Parcelles<br>(N)"),
    n_non_gps = gt::html("Sans mesure<br>(N)"),
    petit = gt::html("Trop<br>petite"),
    panne = gt::html("GPS en<br>panne"),
    indisponible = gt::html("Ménage<br>indisponible"),
    loin = gt::html("Trop<br>éloignée"),
    autre = "Autre",
    sans_motif = gt::html("Sans<br>motif")
) %>%
gt::tab_spanner(
    columns = c(petit, panne, indisponible, loin, autre, sans_motif),
    label = "Motif de non-mesure (%)"
) %>%
gt::fmt_number(
    columns = c(petit, panne, indisponible, loin, autre, sans_motif),
    decimals = 2,
    scale_by = 100
) %>%
style_table()

```

# 10. Fréquence de rejet

## 10.1 Par équipe

```{r rejection_by_team}

reject_actions <- c(
    7,  # RejectedBySupervisor
    8   # RejectedByHeadquarter
)

rejections_count <- equipe_enqueteur_entretien |>
    # remove date and week of interview completion
    # date and week vars are created times in actions file
    dplyr::select(-date, -week) |>
    dplyr::left_join(suso_actions, by = c("interview__id", "interview__key")) |>
    dplyr::mutate(
        rejected = action %in% reject_actions,
        date = lubridate::ymd(date),
		week = lubridate::floor_date(
            lubridate::ymd(date), 
            unit = "week", 
			week_start = getOption("lubridate.week.start", 1)
        ),        
        this_week = date %within% 
            lubridate::interval(
                start = lubridate::ymd(params$rapport_debut), 
                end = lubridate::ymd(params$rapport_fin)
            ),
        rejected_this_week = rejected == 1 & this_week == 1
    ) |>
    dplyr::select(
        supervisor, interviewer, week,
        rejected, rejected_this_week
    ) |>
    dplyr::arrange(supervisor, week) |>
    dplyr::group_by(supervisor, week) |>
    dplyr::summarise(
        dplyr::across(
            .cols = c(rejected, rejected_this_week),
            .fns = ~ sum(.x, na.rm = TRUE)
        )
    ) |>
    dplyr::ungroup()

rejections_by_group <- rejections_count |>
    dplyr::group_by(supervisor) |>
    dplyr::filter(!is.na(week), .preserve = TRUE) |> # remove empty weeks but retain groups with only empty weeks
    dplyr::arrange(week) |>
    dplyr::summarise(
        rejected_this_week = sum(rejected_this_week, na.rm = TRUE),
        rejected_series = list(rejected)
    ) |>
    dplyr::ungroup()

rejections_overall <- rejections_count |>
    dplyr::filter(!is.na(week)) |>
    dplyr::group_by(week) |>
    dplyr::summarise(
        dplyr::across(
            .cols = c(rejected, rejected_this_week),
            .fns = ~ sum(.x, na.rm = TRUE)
        )        
    ) |>
    dplyr::ungroup() |>
    dplyr::arrange(week) |>
    dplyr::summarise(
        rejected_this_week = sum(rejected_this_week, na.rm = TRUE),
        rejected_series = list(rejected)
    ) |>
    dplyr::mutate(supervisor = "Ensemble") |>
    dplyr::relocate(supervisor)

rejections <- dplyr::bind_rows(
    rejections_overall, rejections_by_group
)

reactable::reactable(
    data = rejections,
    columns = list(
        supervisor = reactable::colDef(
            name = "Équipe",
            width = 150
        ),
        rejected_this_week = reactable::colDef(
            name = "Du rapport",
            width = 150
        ),
        rejected_series = reactable::colDef(
            name = "De l'enquête",
            width = 300,
            cell = function(value, index) {
                dataui::dui_sparkline(
                    data = value,
                    components = list(
                        dataui::dui_sparklineseries(
                            # styling
                            stroke = "red",
                            showArea = TRUE,
                            fill = "red"
                        ),
                        dataui::dui_tooltip(
                            dataui::dui_sparkpointseries(
                                #styling
                                stroke = "red",
                                fill = "#fff",
                                #litle extra interactivity for demostration purposes
                                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                            )
                        )
                    )
                )
            }            
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Pendant la période ...",
            columns = c("rejected_this_week", "rejected_series")
        )
    ),
    striped = TRUE,
    searchable = TRUE,
    compact = TRUE,
    fullWidth = FALSE,
    theme = reactable::reactableTheme(
        headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
        groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
        stripedColor = "#edfaea",
        searchInputStyle = list(
            backgroundColor = "#edfaea",
            borderColor = "#8cc0a5",
            borderWidth = "medium",
            "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
            "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
            "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
        )
    )
)

```

## 10.2 Par motif

```{r errors_freq}

errors <- comments %>%
    dplyr::filter(stringr::str_starts(variable, "@@Rejected")) %>%
    tidyr::separate_rows(sep = "\n") %>%
    dplyr::select(interview__id, interview__key, error = comment, date) %>%
    dplyr::mutate(
        date = lubridate::ymd(date),
		week = lubridate::floor_date(
            date, 
            unit = "week", 
			week_start = getOption("lubridate.week.start", 1)
        ),        
        error_this_week = date %within% 
            lubridate::interval(
                start = lubridate::ymd(params$rapport_debut), 
                end = lubridate::ymd(params$rapport_fin)
            )
    ) %>%
    dplyr::arrange(error, week) %>%
    dplyr::group_by(error, week) %>%
    dplyr::summarise(
        error_this_week = sum(error_this_week, na.rm = TRUE),
        n_errors = dplyr::n()
    ) %>%
    dplyr::ungroup() %>%
    dplyr::group_by(error) %>%
    dplyr::summarise(
        error_this_week = sum(error_this_week, na.rm = TRUE),
        error_series = list(n_errors)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(dplyr::desc(error_this_week))

reactable::reactable(
    data = errors,
    columns = list(
        error = reactable::colDef(
            name = "Erreur",
            width = 300
        ),
        error_this_week = reactable::colDef(
            name = "Du rapport",
            width = 150
        ),
        error_series = reactable::colDef(
            name = "De l'enquête",
            width = 300,
            cell = function(value, index) {
                dataui::dui_sparkline(
                    data = value,
                    components = list(
                        dataui::dui_sparklineseries(
                            # styling
                            stroke = "red",
                            showArea = TRUE,
                            fill = "red"
                        ),
                        dataui::dui_tooltip(
                            dataui::dui_sparkpointseries(
                                #styling
                                stroke = "red",
                                fill = "#fff",
                                #litle extra interactivity for demostration purposes
                                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                            )
                        )
                    )
                )
            }            
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Pendant la période ...",
            columns = c("error_this_week", "error_series")            
        )
    ),
    striped = TRUE,
    sortable = TRUE, 
    searchable = TRUE,
    compact = TRUE,
    theme = reactable::reactableTheme(
        headerStyle = list(color = "#ffffff", background = "#0F2B1D"),
        groupHeaderStyle = list(color = "#ffffff", background = "#0F2B1D"),
        stripedColor = "#edfaea",
        searchInputStyle = list(
            backgroundColor = "#edfaea",
            borderColor = "#8cc0a5",
            borderWidth = "medium",
            "&:focus" = list(backgroundColor = "#edfaea", borderWidth = "thick", borderColor = "#0F2B1D"),
            "&:hover, &:focus" = list(borderWidth = "thick", borderColor = "#8cc0a5"),
            "&:hover::placeholder, &:focus::placeholder" = list(color = "#8cc0a5")            
        )
    ) 
)

```

# 11. Fréquence d'erreur de validation

```{r validation_errors}

validation_errors <- suso_errors |>
    dplyr::left_join(equipe_enqueteur_entretien, by = c("interview__id", "interview__key")) |>
    dplyr::filter(
        # dans la période du rapport (ou un superviseur sans obs)
        report_period %in% c(TRUE, NA) & 
        # entretiens achevés (ou un superviseur sans obs)
        is_complete %in% c(TRUE, NA)
    ) %>%
    dplyr::filter(message != "" & !is.na(message)) |>
    dplyr::group_by(message, week) |>
    dplyr::summarise(
        message_this_week = sum(report_period == TRUE),
        n_messages = dplyr::n()
    ) |>
    dplyr::ungroup() |>
    dplyr::arrange(week) |>
    dplyr::group_by(message) |>
    dplyr::summarise(
        dplyr::across(
            .cols = c(message_this_week, n_messages),
            ..fns = ~ sum(.x, na.rm = TRUE)
        ),
        trend_messages = list(n_messages)
    ) |>
    dplyr::ungroup() |>
    dplyr::select(message, message_this_week, trend_messages) |>
    dplyr::arrange(desc(message_this_week))

reactable::reactable(
    data = validation_errors,
    columns = list(
        message = reactable::colDef(
            name = "Erreur de validation",
            width = 200
        ),
        message_this_week = reactable::colDef(
            name = "Du rapport",
            width = 100
        ),
        trend_messages = reactable::colDef(
            name = "De l'enquête",
            width = 300,
            cell = function(value, index) {
                dataui::dui_sparkline(
                    data = value,
                    components = list(
                        dataui::dui_sparklineseries(
                            # styling
                            stroke = "red",
                            showArea = TRUE,
                            fill = "red"
                        ),
                        dataui::dui_tooltip(
                            dataui::dui_sparkpointseries(
                                #styling
                                stroke = "red",
                                fill = "#fff",
                                #litle extra interactivity for demostration purposes
                                renderLabel = htmlwidgets::JS("(d) => d.toFixed(2)")
                            )
                        )
                    )
                )
            }
        )
    ),
    columnGroups = list(
        reactable::colGroup(
            name = "Pendant la période ...",
            columns = c("message_this_week", "trend_messages")
        )
    ),    
    striped = TRUE,
    searchable = TRUE,
    compact = TRUE,
    fullWidth = FALSE,
    theme = reactable_style,
    language = reactable_fr    
)

```
